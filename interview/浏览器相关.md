1. XSS攻击？
- 概念定义：
  - XSS攻击指的是跨站脚本攻击，是一种代码注入攻击；
  - 攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等；
  - XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行；
- 攻击类型：
  - 存储型：指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行；
  - 反射型：指的是攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成XSS攻击；
  - DOM型：指的通过修改页面的DOM节点形成的XSS；
- 防御措施：
  - 可以从浏览器的执行来进行预防，
    - 一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）；
    - 另一种是对需要插入到HTML中的代码做好充分的转义；
    - 对于DOM型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断；
  - 使用CSP，CSP的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击；
  - 对一些敏感信息进行保护，比如cookie使用http-only，使得脚本无法获取，也可以使用验证码，避免脚本伪装成用户执行一些操作；

2. CSRF攻击？
- 概念定义：
  - CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求；
  - 如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作；
  - CSRF攻击的本质是****利用cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充；
- 攻击类型：
  - GET类型：比如在网站中的一个img标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交；
  - POST类型：比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单；
  - 链接类型：比如在a标签的href属性里构建一个请求，然后诱导用户去点击；
- 防御措施：
  - 进行同源检测：服务器根据http请求头中origin或者referer信息来判断请求是否为允许访问的站点，从而对请求进行过滤；
  - 使用CSRF token进行验证：服务器向用户返回一个随机数token，当网站再次发起请求时，在请求参数中加入服务器端返回的token，然后服务器对这个token进行验证。
  - 对Cookie进行****双重验证：服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从cookie中取出这个字符串，添加到URL参数中，然后服务器通过对cookie中的数据和参数中的数据进行比较，来进行验证；
  - 在设置cookie属性的时候设置Samesite，限制cookie不能作为被第三方使用，从而可以避免被攻击者利用；

3. 网络劫持有哪几种，如何防范？
- DNS****劫持：（输⼊京东被强制跳转到淘宝这就属于dns劫持）
  - DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器；
  - 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的，再对劫持的内存发起302跳转的回复，引导⽤户获取内容；
- HTTP****劫持：（访问⾕歌但是⼀直有贪玩蓝⽉的⼴告）
  - 由于http明⽂传输，运营商会修改你的http响应内容（即加⼴告）；
- DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持；
- ⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容；

4. 如何实现浏览器内多个标签页之间的通信?
- 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的；
- 因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发；

- 通信方法如下：
  - 使用websocket协议：因为websocket协议可以实现服务器推送，所以服务器就可以用来当做这个中介者，标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发；
  - 使用ShareWorker的方式：shareWorker会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程，这个时候共享线程就可以充当中介者的角色，标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换；
  - 使****用localStorage的方式：我们可以在一个标签页对localStorage的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据，这个时候localStorage对象就是充当的中介者的角色；
  - 使用postMessage方法，如果我们能够获得对应标签页的引用，就可以使用postMessage方法进行通信；

5. 强缓存和协商缓存的区别：
- 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求；
- 强缓存策略可以通过两种方式来设置，分别是http头信息中的Expires属性和Cache-Control属性：
  - 服务器通过在响应头中添加Expires属性，来指定资源的过期时间，在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求；
  - HTTP 1.1中提出了一个新的头部属性就是Cache-Control属性，它提供了对资源的缓存的更精确的控制，它有很多不同的值；
    - no-cache：是指先要和服务器确认是否有资源更新，再进行判断，也就是说没有强缓存，但是会有协商缓存；
    - no-store：是指不使用任何缓存，每次请求都直接从服务器获取资源；
  - 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control的优先级要高于Expires；

- 命中协商缓存的条件有两个：max-age=xxx过期了和值为no-store；
- 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个304状态，让浏览器使用本地的缓存副本，如果资源发生了修改，则返回修改后的资源；
- 协商缓存也可以通过两种方式来设置，分别是http头信息中的Etag和Last-Modified属性；
  - 服务器在返回资源的时候，在头信息中添加了Etag属性，这个属性是资源生成的唯一标识符，
    - 当资源发生改变的时候，这个值也会发生改变；
    - 在下一次资源请求时，浏览器会在请求头中添加一个If-None-Match 属性，这个属性的值就是上次返回的资源的Etag的值；
    - 服务接收到请求后会根据这个值来和资源当前的Etag的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源；
  - 服务器通过在响应头中添加Last-Modified属性来指出资源最后一次修改的时间，
    - 当浏览器下一次发起请求时，会在请求头中添加一个If-Modified-Since的属性，属性值为上一次资源返回时的Last-Modified的值；
    - 当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改；
    - 如果资源没有修改，那么返回304状态，让客户端使用本地的缓存；
    - 如果资源已经被修改了，则返回修改后的资源；
- 当Etag属性Last-Modified同时出现的时候，Etag的优先级更高；

- **总结**：
  - 强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求；
  - 它们缓存不命中时，都会向服务器发送请求来获取资源；
  - 在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的；
  - 浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源，如果不命中则根据头信息向服务器发起请求，使用协商缓存；
  - 如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器；

6. 为什么需要浏览器缓存？
- 对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地;
- 如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可;
- 如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地，这样就大大的减少了请求的次数，提高了网站的性能；

- 所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了；
- 使用浏览器缓存，有以下优点：
  - 减少了服务器的负担，提高了网站的性能；
  - 加快了客户端网页的加载速度；
  - 减少了多余网络数据传输；

7. 浏览器渲染优化？
- 针对javascript（javaScript既会阻塞HTML的解析，也会阻塞CSS的解析，因此我们可以对javaScript的加载方式进行改变，来进行优化）：
  - 尽量将JavaScript文件放在body的最后，body中间尽量不要写```<script>```标签；
  - ```<script>```标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用async属性和defer属性异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析;
  - 三者的区别如下：
    - script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
    - async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
    - defer 是在下载完成之后，立即异步加载，加载好后，
      - 如果DOM树还没构建好，则先等DOM树解析好再执行，
      - 如果DOM树已经准备好，则立即执行；
      - 多个带defer属性的标签，按照顺序执行；

- 针对CSS：
  - 使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式，它们之间的区别：
    - link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码；
    - @import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)；
    - style：GUI直接渲染；
  - 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度，所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式；
  - 在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中；

- 针对DOM树、CSSOM树：
  - HTML文件的代码层级尽量不要太深；
  - 使用语义化的标签，来避免不标准语义化的特殊处理；
  - 减少CSS代码的层级，因为选择器是从左向右进行解析的；

- 减少回流与重绘：
  - 操作DOM时，尽量在低层级的DOM节点进行操作；
  - 不要使用table布局，一个小的改动可能会使整个table进行重新布局；
  - 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式；
  - 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素；
  - 避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中；
  
8. 什么是同源策略？
- 同源指的是：protocol（协议）、domain（域名）、port（端口）三者必须一致；
- 跨域问题其实就是浏览器的同源策略造成的；
- 同源政策主要限制了三个方面：
  - 当前域下的js脚本不能够访问其他域下的cookie、localStorage和indexDB；
  - 当前域下的js脚本不能够操作访问操作其他域下的DOM。
  - 当前域下ajax无法发送跨域请求；

- 同源政策的目的主要是为了保证用户的信息安全，它只是对js脚本的一种限制，并不是对浏览器的限制；
- 对于一般的img、或者script脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作；

9. 如何解决跨域问题：
- CORS（跨域资源共享）：
  - CORS是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin（domain）上的Web应用被准许访问来自不同源服务器上的指定的资源；
  - 需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与；
  - 因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了；
- JSONP：
  - jsonp的原理就是利用```<script>```标签没有跨域限制；
  - 通过```<script>```标签src属性，发送带有callback参数的GET请求；
  - 服务端将接口返回数据拼凑到callback函数中，返回给浏览器；
  - 浏览器解析执行，从而前端拿到callback函数返回的数据；
- postMessage跨域：
  - postMessage是HTML5 XMLHttpRequest Level2中的API，且是为数不多可以跨域操作的window属性之一，
  - 它可用于解决以下方面的问题：
    - 页面和其打开的新窗口的数据传递；
    - 多窗口之间消息传递；
    - 页面与嵌套的iframe消息传递；
    - 上面三个场景的跨域数据传递；
- nginx代理跨域：实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段；
- nodejs中间件代理跨域：
  - 原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发；
  - 也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证；
- WebSocket协议跨域：
  - WebSocket protocol是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现；
  - 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容；

10. 宏任务和微任务分别有哪些？
- 宏任务包括：script脚本的执行、setTimeout，setInterval，setImmediate一类的定时事件，还有如I/O操作、UI渲染等；
- 微任务包括：promise的回调、node中的process.nextTick、对Dom变化监听的MutationObserver；

11. 哪些操作会造成内存泄漏？
- 意外的全局变量：使用未声明的变量，意外创建全局变量，无法被回收；
- 定时器：未被正确关闭，导致所引用的外部变量无法被释放；
- DOM引用：DOM元素被删除时，内存中的引用未被正确清空；
- 闭包：会导致父级中的变量无法被释放；
