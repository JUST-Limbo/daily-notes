#### 1. 对vue的认识

> vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的。

#### 2. vue生命周期

> vue生命周期总共分为8个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。
>
> - beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化；
> - created (创建后) 完成了 data数据初始化, el还未初始化；
> - beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上；
> - mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互；
> - beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程；
> - updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用；
> - beforeDestroy  (销毁前） 在实例销毁之前调用。实例仍然完全可用；
> - destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

#### 3. vue与react的区别

> - react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；
> - vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。
>
> - =>  相同点：
>
    >> 1. 数据驱动页面，提供响应式的视图组件；
    >> 2. 都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范；
    >> 3. 数据流动单向，都支持服务器的渲染SSR；
    >> 4. 都有支持native的方法，react有React native， vue有wexx；
>
> - =>  不同点：
>
    >> 1. 数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的；
    >> 2. 数据渲染：大规模的数据渲染，react更快；
    >> 3. 使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目；
    >> 4. 开发风格：react推荐做法jsx + inline style把html和css都写在js了，vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件。

#### 4. MVVM框架

> MVVM 是 Model-View-ViewModel 的缩写。
>
> - Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；
> - View 代表UI 组件，它负责将数据模型转化成UI 展现出来；
> - ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。

#### 5. v-model的原理

> - Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的；
> - 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作，在数据变动时作你想做的事。
> - 原理：
通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新；
在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据。

#### 6. 组件间的通信

> - 父组件向子组件传值：父组件可以使用props向子组件传递数据；
> - 子组件向父组件传值：子组件通过$emit触发事件，回调给父组件；
> - 非父子, 兄弟组件之间通信：可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。

#### 7. computed和watch的区别

> 如果一个数据依赖于其他数据，那么把这个数据设计为computed的；如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。
>
> - computed主要用于对同步数据的处理；
> - watch则主要用于观测某个值的变化去完成一段开销较大的复杂业务逻辑；
> - computed和watch都起到监听/依赖一个数据，并进行处理的作用，它们其实都是vue对监听器的实现。

#### 8. vue.extend和vue.component

> - extend
是构造一个组件的语法器，
然后这个组件你可以作用到Vue.component这个全局注册方法里
还可以在任意vue模板里使用组件，
也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件；
> - Vue.component
你可以创建 ，也可以取组件。

#### 9. 为什么虚拟DOM会提高性能

> 虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。
>
> 具体实现步骤：
>
> 1. 用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中；
> 2. 当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异；
> 3. 把步骤 2 所记录的差异应用到步骤 1 所构建的真正的DOM树上，视图就更新了。
